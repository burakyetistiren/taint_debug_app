.decl edge(id:number, x:number, y:number)
.input edge

.decl node(id:number)
.input node

.decl library_node(edge:number, id:number)
.input library_node

.decl path1(node:number, step:number, lib: number)
.output path1

.decl path2(node:number, step:number, lib: number)
.output path2

.decl common_path( lib: number)
.output common_path

.decl start1(x:number)
.input start1

.decl end1(x:number)
.input end1

.decl start2(x:number)
.input start2

.decl end2(x:number)
.input end2

// find common paths 

path1(node, 0, 0) :- start1(node).
path1(next, step+1, lib) :- path1(node, step, _), edge(_, node, next), library_node(next, lib), end1(end), node != end, step < 10.
path1(next, step+1, -1) :- path1(node, step, _), edge(_, node, next), !library_node(next, _), end1(end), node != end, step < 10.


path2(node, 0, 0) :- start2(node).
path2(next, step+1, lib) :- path2(node, step, _), edge(_, node, next), library_node(next, lib), end2(end), node != end, step < 10.
path2(next, step+1, -1) :- path2(node, step, _), edge(_, node, next), !library_node(next, _), end2(end), node != end, step < 10.


common_path(lib) :- path1(_, _, lib), path2(_, _, lib), lib != -1.
